package me.vrekt.oasis.utility.collision;

import com.badlogic.gdx.maps.MapObject;
import com.badlogic.gdx.maps.objects.EllipseMapObject;
import com.badlogic.gdx.maps.objects.PolygonMapObject;
import com.badlogic.gdx.maps.objects.PolylineMapObject;
import com.badlogic.gdx.maps.objects.RectangleMapObject;
import com.badlogic.gdx.math.Ellipse;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.*;
import com.badlogic.gdx.utils.Array;

/**
 * Basic utility class to create collision shapes
 */
public final class CollisionShapeCreator {

    public static final BodyDef STATIC_BODY = new BodyDef();

    public static Array<Rectangle> rectangles = new Array<>();

    static {
        STATIC_BODY.type = BodyDef.BodyType.StaticBody;
    }

    /**
     * Create a collision object within a box2d world.
     *
     * @param object object
     * @param scale  scale
     * @param bw     box2d world
     */
    public static void createCollisionInWorld(MapObject object, float scale, World bw) {
        switch (object) {
            case PolylineMapObject polylineMapObject -> createPolylineShapeInWorld(polylineMapObject, scale, bw);
            case PolygonMapObject polygonMapObject -> createPolygonShapeInWorld(polygonMapObject, scale, bw);
            case RectangleMapObject rectangleMapObject ->
                    createPolygonShapeInWorld(rectangleMapObject, scale, true, bw);
            case EllipseMapObject ellipseMapObject -> createEllipseShapeInWorld(ellipseMapObject, scale, bw);
            default -> throw new IllegalStateException("Unexpected value: " + object);
        }
    }

    /**
     * Create a basic ellipse shape in the world.
     * This method is rough and does not produce exact results.
     *
     * @param object object
     * @param scale  scale
     * @param bw     world
     */
    public static void createEllipseShapeInWorld(EllipseMapObject object, float scale, World bw) {
        // scale ellipse to watch the in game world position
        object.getEllipse().x *= scale;
        object.getEllipse().y *= scale;
        object.getEllipse().width *= scale;
        object.getEllipse().height *= scale;

        final PolygonShape polygonShape = ellipseToPolygon(object.getEllipse(), 8);
        final Body body = bw.createBody(STATIC_BODY);
        body.createFixture(polygonShape, 1.0f);
        body.setUserData(CollisionType.MAP_BOUNDS);
        polygonShape.dispose();
    }

    /**
     * Code generated by ChatGPT, unfortunately there was no way to figure this out myself, works well enough.
     *
     * @param ellipse     the ellipse
     * @param numVertices anyting > 8 will crash.
     * @return the new shape
     */
    public static PolygonShape ellipseToPolygon(Ellipse ellipse, int numVertices) {
        final PolygonShape polygonShape = new PolygonShape();
        final Vector2[] vertices = new Vector2[numVertices];

        final float centerX = ellipse.x + ellipse.width / 2;
        final float centerY = ellipse.y + ellipse.height / 2;
        final float radiusX = ellipse.width / 2;
        final float radiusY = ellipse.height / 2;
        final float angleStep = 2 * (float) Math.PI / numVertices;

        for (int i = 0; i < numVertices; i++) {
            float angle = i * angleStep;
            float x = (float) Math.cos(angle) * radiusX + centerX;
            float y = (float) Math.sin(angle) * radiusY + centerY;
            vertices[i] = new Vector2(x, y);
        }

        polygonShape.set(vertices);
        return polygonShape;
    }

    /**
     * Create a polygon shape and add it to the world using the {@code STATIC_BODY}
     * <a href="https://stackoverflow.com/questions/45805732/libgdx-tiled-map-box2d-collision-with-polygon-map-object">...</a>
     *
     * @param object the object
     * @param scale  the scale
     * @param bw     the box2d world.
     */
    public static Body createPolygonShapeInWorld(PolygonMapObject object, float scale, World bw) {
        final float[] vertices = object.getPolygon().getTransformedVertices();
        final float[] world = new float[vertices.length];

        for (int i = 0; i < world.length; i++) {
            world[i] = vertices[i] * scale;
        }

        final PolygonShape shape = new PolygonShape();
        shape.set(world);

        final Body body = bw.createBody(STATIC_BODY);
        body.createFixture(shape, 1.0f);
        shape.dispose();
        return body;
    }

    /**
     * Create a polyline shape and add it to the world using the {@code STATIC_BODY}
     * <a href="https://stackoverflow.com/questions/45805732/libgdx-tiled-map-box2d-collision-with-polygon-map-object">...</a>
     *
     * @param object the object
     * @param scale  the scale
     * @param bw     the box2d world.
     */
    public static void createPolylineShapeInWorld(PolylineMapObject object, float scale, World bw) {
        final float[] vertices = object.getPolyline().getTransformedVertices();
        final Vector2[] world = new Vector2[vertices.length / 2];

        for (int i = 0; i < world.length; i++) {
            final Vector2 vec = new Vector2(vertices[i * 2] * scale, vertices[i * 2 + 1] * scale);
            world[i] = vec;
        }

        final ChainShape shape = new ChainShape();
        shape.createChain(world);

        final Body body = bw.createBody(STATIC_BODY);
        body.createFixture(shape, 1.0f);
        body.setUserData(CollisionType.MAP_BOUNDS);

        shape.dispose();
    }

    /**
     * Create individual path points along a poly-line map object
     *
     * @param object object
     * @param scale  scale
     * @return the points
     */
    public static Vector2[] createPathPoints(PolylineMapObject object, float scale) {
        final float[] vertices = object.getPolyline().getTransformedVertices();
        final Vector2[] world = new Vector2[vertices.length / 2];

        for (int i = 0; i < world.length; i++) {
            final Vector2 vec = new Vector2(vertices[i * 2] * scale, vertices[i * 2 + 1] * scale);
            world[i] = vec;
        }

        return world;
    }

    /**
     * Create a polygon shape and add it to the world using the {@code STATIC_BODY}
     *
     * @param object the object
     * @param scale  the scale
     * @param ds     if you should scale
     * @param bw     the box2d world.
     */
    public static Body createPolygonShapeInWorld(RectangleMapObject object, float scale, boolean ds, World bw) {
        final PolygonShape shape = new PolygonShape();
        final Rectangle rectangle = new Rectangle(object.getRectangle());

        if (ds) {
            rectangle.x *= scale;
            rectangle.y *= scale;
            rectangle.width *= scale;
            rectangle.height *= scale;
        }

        rectangles.add(rectangle);

        final Vector2 center = new Vector2(rectangle.x + rectangle.width / 2f, rectangle.y + rectangle.height / 2f);
        shape.setAsBox(rectangle.width / 2, rectangle.height / 2, center, 0.0f);

        final Body body = bw.createBody(STATIC_BODY);
        body.createFixture(shape, 1.0f);
        body.setUserData(CollisionType.MAP_BOUNDS);

        shape.dispose();
        return body;
    }

    public static Body createPolygonShapeInWorld(float x, float y, float width, float height, float scale, boolean ds, World bw) {
        final PolygonShape shape = new PolygonShape();

        if (ds) {
            width *= scale;
            height *= scale;
        }

        final Vector2 center = new Vector2(x + width / 2f, y + height / 2f);
        shape.setAsBox(width / 2, height / 2, center, 0.0f);

        final Body body = bw.createBody(STATIC_BODY);
        body.createFixture(shape, 1.0f);
        body.setUserData(CollisionType.MAP_BOUNDS);

        shape.dispose();
        return body;
    }

}
